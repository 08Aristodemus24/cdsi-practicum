

update resume to include x++ and dynamics 365 finance and operations development
update linked in profile

time mark:
reports 8PM1 - 3:05:13
security basics, data entities 9AM1 - 2:32:58

topics:
learn what you need to know then study those that you vaguely know because of time restriction deply


to extend a prebuilt in this case menu we can do it by right clicking a pre built menu in the AOT, and clicking create extension
menu artifacts
drag the created menu in the resources folder of the newly extended menu
and under dragged menu we drag under it our created menu items
a menu item button is like a navbar link or a navigation link maybe navbars in general are just menus 
clicking the run button in the IDE will launch the server that will locally host our application

Learning fast:
try to watch the videos so you can have already knowledge on what the instructors are doing 
know what they discuss
look up what they discuss in the documentation because it si bound to be there
read it and get the knowledge that you can
then watch the videos again and see how they implement it, there is no need to read what is in the videos
code along with your own version
screenshot your code and save it with doodles for side notes


password for serving the project loaclly



everytime a table, data entity, report, changes sync db
everytime we need a package udpate our model parameters
everytime a report changes clean build and then deploy if report does not work try to restart SSRS service in the services application


DaY 4
Exception handling

file: DBFMVehicleEntry.xpp
DBFMVehicleTableTest vehicle_table;

public void run()
{
	this.setupDialog();
	Dialog.run();
	Dialog.wait();
	if(Dialog.closeOk())
	{
		this.getFieldValues();
		if(vehicle_table.validateWrite())
		{
			vehicle_table.insert();
			DBFMVehicleEntry::tableInsertSuccess();
		}
	}
}

public void getFieldValues()
{
	str make, model, VIN;
	int vehicle_id;
	DBFMFuelLevel fuel_level;

	make = df_make.value();
	model = df_model.value();
	VIN = df_vin.value();
	fuel_level = df_fuel_level.value();

	try
	{
		if(strlen(VIN) < 18)
		{
			throw error("Invalid VIN. Cannot be fewer than 18 characters. Appending characters");
		}
		else
		{
		
		}
	}

	catch{
		// see how many 0s are needed for the VIN to be valid
		// e.g. VIN is 7 in length missing 11 0s
		for(int i = 0; i < 18 - strlen(VIN); ++i)
		{
			VIN += "0";
		}
		retry;
	}

	vehicle_table.DBFMMakeTest = make;
	vehicle_table.DBFMModelTest = model;
	vehicle_table.DBFMVINTest = VIN;
	vehicle_table.DBFMFuelLevelTest = fuel_level;
}


// if VIN is less than 18 characters throw an error but retry the try block and append now the missing characters through 0s for the VIN field

public void setupDialog()
{

	// to add 
	df_fuel_level = Dialog.addField(extendedTypeStr(DBFMFuelLevelTest), "Fuel level");
}






DBFMVehicleTable.xpp

public class DBFMVehicleTable extends common
{
	public void initValue()
	{
		super();
	}

	public void insert()
	{
		super();
	}

	// method runs when modifying a field, takes in a field that was modified
	public void modifiedField(Field _fieldId)
	{
		super(_fieldId);

		switch(_fieldId)
		{
			// fieldNum(<table name>, <table field>)
			case fieldNum(DBFMVehicleTableTest, DBFMServiceTypeCodeTest):
				info("service type field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMSeatingCapacityTest):
				info("seating capacity field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMModel):
				info("model field is updated");
				break;
		}
	}

	public boolean validateWrite()
	{
		boolean is_valid = super();
		if(this.DBFMFuelLevel < 10)
		{
			is_valid = false;
			error("fuel level must be greater than or equal 10");
		}
	
		return is_valid;
	}
}







file: CustCreateCustomer.xpp
public void run()
{
CustTable cust_table;
Currency curr_table;

Dialog dialog = new Dialog("Create new customer");
DailogField df_cust_acc = Dialog.addField(extendedTypeStr(CustVendAc), "Account number");
DialogField df_group = Dialog.addField(extendedTypeStr(CustGroupId), "Group");
DialogField df_credit_rating = Dialog.addField(extendedTypeStr(CustCreditRating), "Credit rating");

const int MAX_RETRIES = 5;
int retry_count = 0;


if(dialog.run()){
try
{
	cust_table.AccountNum = df_cust_acc.value();
	cust_table.CustGroup = df_group.value();
	cust_table.CreditRating = df_credit_rating.value();
	if(!cust_table.validateWrite())
	{
		// this will throw an error since the currency field is not supplied a value;
		throw error("Please enter all required fields");
	}
	else
	{
		cust_table.insert();
	}
}
catch(Exception::Error)
{
	// check if Currency field is indeed blank
	if(!cust_table.Currency)
	{
		select firstonly curr_table;
		cust_table.Currency = curr_table.CurrencyCode;
		if(retry_count <= MAX_RETRIES)
		{
			++retry_count;
			retry;
		}
	}
	else
	{
		error("An error occured. please try again");
	}
}
}
}



DBFMBaseClass.xpp
class DBFMBaseClass
{
	public int curr_state;
	
	public int permState(int _value=curr_state)
	{
		curr_state = _value;
		return curr_state;
	}

	public void displayState()
	{
		info(strFmt("DBFMBaseClass state: %1", this.permState()));
	}
}



DBFMBaseClass_Extension.xpp
[ExtensionOf(classStr(DBFMBaseClass))]
final class DBFMBaseClass_Extension
{
	public void setCustomState(int cust_state)
	{
		this.permState(cust_state);
	}
	
	public void displayState()
	{
		warning("from extension class");
		next displayState();
		warning("from extension class");
	}
}



DBFMChildClass.xpp
class DBFMChildClass extends DBFMBaseClass
{
	public void displayState()
	{
		info("child class before super()");
		super();
		info("child class after super");
	}
}



DBFMChildClass_Extension.xpp
[ExtensionOf(classStr(DBFMChildClass))]
final class DBFMChildClass_Extension
{
	public void displayState()
	{
		info("Child class extension before next");
		next displayState();
		info("Child class extension after next");
	}
}



DBFMExtendedClasses.xpp
class DBFMExtendedClasses
{
	public static void main(Args _args)
	{
		// we still call the normal name of a now extended class
		DBFMBaseClass bc = new DBFMBaseClass();
		bc.displayState();
		bc.setCustomeState(10000);
		bc.displayState();

		DBFMChildClass cc = new DBFMChildClass();
		cc.displayState();
		cc.setCustomeState(50000);
		cc.displayState();
	}

	
}



CustTableDBFM_Extension.xpp
[ExtensionOf(tableStr(CustTable))]
final class CustTableDBFM_Extension
{
	// does this override the this.insert() method of the CustTable table
	void insert(DirPartyType _partyType, Name _name, boolean _updateCRM)
	{
		next insert(_partyType, _name, _updateCRM);
	}

}




next keyword is akin to super() method to call the original method of the parent class
next cannot also be written inside conditional statements scopes
The next keyword behaves like a super, and it will define when your extended logic executes
The next call after your code behaves like a Pre-event handler. Your logic executes first, and later on, the logic residing in the original method gets executed


Activity 1:
-COC enabled strongly typed extension capabilities of public and protected methods
-it allows technical consultants to extend the application avoiding over-layering
-to use COC you must declare your class as final and your methods should always contain the next keyword
-only public and protected methods are allowed to be extended
-you can add custom logic that will run before and/or after the standar dcode runs
-lyou can access the protected and public methods, and variables of the base class
-you can only extend objects that are part of the referenced packages of your model. This is done through clicking the model parameters under the dynamics 365 menu, and updating the model parameters, the once in the window select the DevelopmentBasicsFMS option, next check the model we are trying to reference always e.g. CustTable for instance. This works like an import statement which adds the model that we check to our current project directory which we can always access at will
-methods with [Hookable(false)] or [Wrappable(false)] attribute cannot be extended
-methods that use the final keyword cannot be wrapped in an extension class
-class name must have an _Extension suffix
-class declaration needs to ouse the final keyword
-add the ExtensionOf attribute on the class
-use COC to extend the following: table, class, form, etc.
-the next keyword is required. This will determine on which part of the code the base class will be called


COCBaseClass.xpp
class COCBaseClass
{
	public void new()
	{
		//
	}

	protected void test()
	{
		info("base class call");
	}

	public void runTest()
	{
		this.test();
	}
}


COCChildClass.xpp
class COCChildClass extends COCBaseClass
{
	// override test() method of parent class
	protected void test()
	{
		info("child class before super");
		//  super() calls the original overriden method of the parent class
		// where ever super() is scoped or the method it is currently in (usually an overriden method)
		// super() assimilates the parent method of that of the overriden method it is inside of
		// and returns (or not) its respective value, in this case the test() method is overriden 
		// and is the method it is inside in, therefore call the parent test() method
		super();
		info("child class after super");
	}
}

COCChildClass_Extension.xpp
[ExtensionOf(classStr(COCChildClass))]
final class COCCHildClass_Extension
{
	protected void test()
	{
		info("extension 1 before next call")
		next test();
		info("extension 1 after next call")
	}
}



[ExtensionOf(tableStr(CustTable))]
final class CustTableDBFM_Extension
{
	void insert(DirPartyType _partyType, Name _name, boolean _updateCRM)
	{
		if(str2Int(this.creditRating) < 200)
		{
			this.Blocked = CustVendorBlocked::All;
			info("The customer has been placed on hold du to low credit rating. Please review");
		}
		next insert(_partyType, _name, _updateCRM);
	}
}




we can also use other built or even pre-built objects like tables and forms in creating extensions of them
e.g. [ExtensionOf(formStr(CustForm))] or [ExtensionOf(tableStr(CustTable))]


we can override methods of the tables we created and pre-built tables by right clicking the methods node of a table and navigating to the override method and selecting the method that we will override
this will then add our overriden method in this node and we can edit this method through x++ code 


DBFMVehicleTable.xpp

public class DBFMVehicleTable extends common
{
	public void initValue()
	{
		super();
	}

	public void insert()
	{
		super();
	}

	// method runs when modifying a field, takes in a field that was modified
	public void modifiedField(Field _fieldId)
	{
		super(_fieldId);

		switch(_fieldId)
		{
			// fieldNum(<table name>, <table field>)
			case fieldNum(DBFMVehicleTableTest, DBFMServiceTypeCodeTest):
				info("service type field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMSeatingCapacityTest):
				info("seating capacity field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMModel):
				info("model field is updated");
				break;
		}
	}

	public boolean validateWrite()
	{
		boolean is_valid = super();
		if(this.DBFMFuelLevel < 10)
		{
			is_valid = false;
			error("fuel level must be greater than or equal 10");
		}
	
		return is_valid;
	}
}


Day 5
Code extension - but what to use extensions or by clicking the override option in the tables that we have, I guess overriding the functionality of a table 

Activity 2:
- set initial value of Year to current date (I guess we can override here the this.initValue() method of a table, use today())
- add validation "year must not be greater than current date"
- add year on dialog (simple Dialog.addField(extendedTypeStr(DBFMYearTest), "year");)
- set initial value of vehicle id to the number next to the greatest value of saved vehicle ids (will probably use the select statement and pickign the max of all vehicle ids, then using this max value for the overriden initValue())
- disable editing of vehicle id on the table (this method already exists as a built in method)

DBFMVehicleEntry.xpp
class DBFMVehicleEntry
{
	DBFMVehicleTableTest vehicle_table;
	Dialog dialog;
	DialogField df_make, df_model, df_VIN, df_vehicle_id, df_fuel_level, df_year;

	public static void main(Args _args)
	{
		DBFMVehicleEntry ve = new DBFMVehicleEntry();
		ve.run();		
	}


	public void run()
	{
		this.setupDialog();
		Dialog.run();
		Dialog.wait();
		if(Dialog.closeOk())
		{
			this.getFieldValues();
			if(vehicle_table.validateWrite())
			{
				vehicle_table.insert();
				DBFMVehicleEntry::tableInsertSuccess();
			}
		}
	}

	public void getFieldValues()
	{
		str make, model, VIN;
		int vehicle_id;
		DBFMFuelLevel fuel_level;

		make = df_make.value();
		model = df_model.value();
		VIN = df_vin.value();
		fuel_level = df_fuel_level.value();

		try
		{
			if(strlen(VIN) < 18)
			{
				throw error("Invalid VIN. Cannot be fewer than 18 characters. Appending characters");
			}
			else
			{
		
			}
		}

		catch{
			// see how many 0s are needed for the VIN to be valid
			// e.g. VIN is 7 in length missing 11 0s
			for(int i = 0; i < 18 - strlen(VIN); ++i)
			{
				VIN += "0";
			}
			retry;
		}

		vehicle_table.DBFMMakeTest = make;
		vehicle_table.DBFMModelTest = model;
		vehicle_table.DBFMVINTest = VIN;
		vehicle_table.DBFMFuelLevelTest = fuel_level;
	}

	public setupDialog()
	{
		vehicle_table.init_value();

		df_make = Dialog.add(extendedTypeStr(DBFMMakeTest), "make");
		df_model = Dialog.add(extendedTypeStr(DBFMModelTest), "model");
		df_VIN = Dialog.add(extendedTypeStr(DBFMVINTest), "vehicle identification number (VIN)");
		df_fuel_level = Dialog.add(extendedTypeStr(DBFMFuelLevelTest), "fuel level");
		df_year = Dialog.add(extendedTypeStr(DBFMYearTest), "year");
		df_vehicle_id = Dialog.add(extendedTypeStr(DBFMModelTest), "model");

		df_vehicle_id.value(vehicle_table.DBFMVehicleIdTest);
		df_vehicle_id.allowEdit(false);
		df_year.value(vehicle_table.DBFMYear);
	}
}



DBFMVehicleTable.xpp
public class DBFMVehicleTable extends common
{
	public void initValue()
	{

		this.DBFMYearTest = today();
		this.DBFMVehicleIdTest = this.getMaxVehicleId() + 1;
		super();
	}

	public void insert()
	{
		super();
	}

	// method runs when modifying a field, takes in a field that was modified
	public void modifiedField(Field _fieldId)
	{
		super(_fieldId);

		switch(_fieldId)
		{
			// fieldNum(<table name>, <table field>)
			case fieldNum(DBFMVehicleTableTest, DBFMServiceTypeCodeTest):
				info("service type field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMSeatingCapacityTest):
				info("seating capacity field is updated");
				break;
			case fieldNum(DBFMVehicleTableTest, DBFMModel):
				info("model field is updated");
				break;
		}
	}

	public boolean validateWrite()
	{
		boolean is_valid = super();
		if(this.DBFMFuelLevel < 10)
		{
			is_valid = false;
			error("fuel level must be greater than or equal 10");
		}

		if(this.DBFMYearTest > today())
		{
			is_valid = false;
			error("year must not be greater than current date")
		}
	
		return is_valid;
	}

	private DBFMVehicleIdTest getMaxVehicleId()
	{
		return (select maxof(DBFMVehicleIdTest) from vehicle_table).DBFMVehicleIdTest;
	}
}



-create new DBFMVehicleTableGenFormTest
-data source: DBFMVehicleTableTest
-pattern: simple list
-add vehicle id, VIN, vehicle type code, year, make, model, gross vehicle weight, 
fuel level, inspect  date, service type code
-create DBFMVehicleGenMenuItem
-add to OrganizationAdministration > Resources > Menus
-becuse validation of VIN is written in our this.getFieldValues() method we must now include it in the this.validateWrite() method


Activity 3:
-using chain of command, set th einitial value of the field VengGroup in the VendTable to the first VendGroup from VendGroup table
-therefore import or include this in our model parameters this VendTable
-build and open accounts payable > vendors > all vendors
-click on new under th action pane and see if the group is set to the initial value


DBFMVendTable_Extension.xpp
[ExtensionOf(tableStr(VendTable))]
final class DBFMVendTable_Extension
{
	public void initValue()
	{
		VendGroup vendGroup;

		// ah ok because fields tables have internally no values
		// then the initValue() method is called to initialize the fields to these values
		// if there is no setting of any field then we can place next initValue() 
		// either at the top or at the bottom
		this.VendGroup = (select firstonly VendGroup from vendGroup).VendGroup;
		next initValue();

		// remember we can now dictate the behavior of the Vendtable because we have already extended it,
		// so this is the class it now uses overall and the initValue() of the base class is not anymore
		// the initValue() method being called but rather this declaration in our extension
	}
}

Delegates allow us to access elements in higher models from a lower model. Below is a model heirarchy
Test 
Application suite
Application foundation
Application platform

exhibit a: application foundation needs something from suite, suite needs to subscribe to application foundation

(1)delegate (2)void  applyDiscountDelegate(real _receiptTotal, EventHandlerResult _result)
{
(3)
}

this is for application suite:
[SubscribesTo(classStr(Simpletax), delegateStr(SimpleTax, applyDiscountDelegate))]
public static void applyDiscountDelegateHandler(real _receiptTotal, EventHandlerResult _result)
{
	real discountedTotal = _receiptTotal * (1 - DiscountRate);
	_result.result(discountedTotal);
}

for application foundation to use application suite:
public real calculateTotalTax()
{
	real totalTax;
	
	EventhandlerResult result;
	this.applyDiscountDelegate(this.ReceiptTotal, result);
	this.ReceiptTotal = result.result();

	totalTax = this.ReceiptTotal * this.TaxRate;

	return totalTax;
}





Event handling

-is exactly like the performCreate(), onDelete(), onInsert(), componentDidMount(), componentWillMount(), events and methods that act as events in the languages you've learned like JavaScript, and Python
-we can override an event handler by creating a class
-copy the onInserting event in the CustTable table that we have included in our project via importing
-create a regular class named DBFMCustTableHandler and paste the onInserting event that we copied in the class

file: DBFMCustTableHandler.xpp
class DBFMCustTableHandler
{
	[DataEventHandler(tableStr(CustTable), DataEventType::Inserting)]
	public static void CustTable_onInserting(Common sender, DataEventArgs e)
	{
		CustTable cust_table = sender;
		if(str2int(cust_table.CreditRating) < 200)
		{
			cust_table.Blocked = CustVendorBlocked::All;
			info("the customer has been placed on hold due to low credit rating. Please review);
		}
	}
}	



-import FMRental forms by checking the FleetManagement package/model
-copy event handler onInitialized
-create another class and paste the onInitialized method
-other events are also nested in the data sources node, besides the root form node itself like OnModified, OnActivated

file: DBFMFMRentalHandler.xpp
class DBFMFMRentalHandler
{
	// under: FMRental
	[FormEventHandler(formStr(FMRental), FormEventType::Initialized]
	public static void FMRental_OnInitialized(xFormRun sender, FormEventArgs e)
	{
		info("initialized form event handler");

		FormRun form_run = sender;
		
		// access this like a tree with its nodes and subnodes
		// to gain access to the field of the form "value" itself
		FormControl fmrental_state_copy_1 = form_run.design().controlName(formControlStr(FMRental_StateCopy1));
		
		if(fmrental_state_copy_1.valueStr() == "Complete")
		{	
			fmrental_state_copy_1.enabled(false);
		}

		info(strFmt("state is initialized as: %1", fmrental_state_copy_1.valueStr()));
		
	}

	// under: FMRental_StateCopy1 < InfoGroup < LineViewHeader < LineViewTab < LineView < TabDetails < TabPageDetails < Tab < FMRental Design Pattern
	[FormControlEventHandler(formControlStr(FMRental, FMRental_StateCopy1), FormControlEventType::Modified]
	public static void FMRental_StateCopy1_OnModified(FormControl sender, FormControlEventArgs e)
	{
		//FMRental_StateCopy1 fmr_sc = sender;	
		// when valueStr() has value "complete" set the form to disabled
		if(sender.valueStr() == "Complete")
		{
			sender.enabled(false);
		}
		info("state %1 has been modified", sender.valueStr());
	}

	// under: events < FMRental < Data Sources < FMRental
	[FormDataSourceEventHandler(formDataSourceStr(FMRental, FMRental), FormDataSourceEventType::Activated)]
	public static void FMRental_OnActivated(FormDataSource sender, FormDataSourceEventArgs e)
	{
		FormRun form_run = sender.formRun();
				
		// access this like a tree with its nodes and subnodes
		// to gain access to the field of the form "value" itself
		FormControl fmrental_state_copy_1 = form_run.design().controlName(formControlStr(FMRental_StateCopy1));
		
		/* if(fmrental_state_copy_1.valueStr() == "Complete")
		{	
			fmrental_state_copy_1.enabled(false);
		}
		else
		{
			fmrental_state_copy_1.enabled(true);
		} */
		
		/* // shorthand of the above
		fmrental_state_copy_1.enabled(fmrental_state_copy_1.valueStr() == "Complete" ? false : true);		
		info(strFmt("state is initialized as: %1", fmrental_state_copy_1.valueStr())); */

		FMRental fm_rental = sender.cursor();
		FormDataObject fm_rental_state = sender.object(fieldNum(FMRental, State));

		fm_rental_state.enabled(fm_rental.State != FMReservatioState::Complete);
		info(strFmt("state is initialized as: %1", fm_rental.State));		

		
	}
	
	// under: events < state < fields < FMRental < data sources < FMRental
	[FormDataFieldEventHandler(formDataFieldStr(FMRental, FMRental, state), FormDataFieldEventType::Modified)]
	public static void State_OnModified(FormDataObject sender, FormDataFieldEventArgs e)
	{

		// because the field is an enum we must compare the field_val
		// to an enum value
		anytype field_val = sender.getValue();
		
		/* if(sender.getValue() == FMReservationState::Complete)
		{
			sender.enabled(false);
		}
		else
		{
			sender.enabled(true);
		} */

		sender.enabled(sender.getValue() != FMReservationState::Complete);
		info(strFmt("state has been modified to: %1", sender.getValue()));
	}

	
}

-sabi na nga eh...to do this we need to go to a specific entity instance and disable the field there. Kasi wala tayo namention na specific instance so nastuck tayo sa form design lang mismo
-we need to access a specific instance, and what instance is it, yes the instances only with fields set to Complete
[<node all words with capitalized first letters>EventHandler(<node all words with capitalized first letters except first word with first lowercase first letter>Str(<...args>), <node all words with capitalized first letters>EventType::<EventType>)]
public static void <naem of the event handler or event to be overriden>(<...args>)
{

}




Activity 4:
-using event handlers disable field "Group" on all vendors form if "Group" has a value, this means that even in cases of inserting a record, updating a record, upon the loading of a record the records must be checked to see if the their group fields are blank
-disable field "UPS zone" on all vendors > invoice and delivery > Delivery if "UPS zone" has a vlaue

file: DBFMVendHandler.xpp
class DBFMVendHandler.xpp
{
	[FormDataSourceEventHandler(formDataSourceStr(VendTable, VendTable), FormDataSourceEventType::Activated)]
	public static void VendTable_OnActivated(FormDataSource sender, FormDataSourceEventArgs e)
	{
		VendTable vend_table = sender.cursor();
		FormDataObject vend_table_fzone = sender.object(fieldNum(VendTable, FreightZone));
		vend_table_fzone.enable(!vend_table.FreightZone);
	}
}


Table Extensions
-the reason why you can't create extension is because the object whether table, form, menu is not imported yet in your project
-so add FMRental table to our project
-add the vehicle id of our DBFMVehicleTableTest to the fields
-add a primary key relation
-use set the properties like assocaiation, cardinality, relationship type and on delete to its respective values
-add a normal field to the relation and set field to vehicle id
-set the related field to the vehicle id as well

file: DBFMVendTable_Extension.xpp
[ExtensionOf(tableStr(VendTable))]
final class DBFMVendTable_Extension
{
	public void initValue()
	{
		VendGroup vendGroup;

		// ah ok because fields tables have internally no values
		// then the initValue() method is called to initialize the fields to these values
		// if there is no setting of any field then we can place next initValue() 
		// either at the top or at the bottom
		this.VendGroup = (select firstonly VendGroup from vendGroup).VendGroup;
		next initValue();

		// remember we can now dictate the behavior of the Vendtable because we have already extended it,
		// so this is the class it now uses overall and the initValue() of the base class is not anymore
		// the initValue() method being called but rather this declaration in our extension
	}

	[SysClientCacheDataMethodAttribute(true)]
	display str customVendGroup()
	{
		return "DBFM_" + this.VendGroup
	}
}


-create an extension of the VendTable form
-go to the pattern tab of the VendTable form and under the MainTab sub pattern di ko na alam kung ano add a string which will represent our custom group
-set the properties data method to the method that we made which is customVendGroup under our extended VendTable, DBFMVendTable_Extension
-set hte data source to our VendTable
-set the label to "Custom Group"



Activity 5a:
-add vehicle id field from DBFMVehicleTableTest on VendTable, and FMRental tables (do this by creating the extension first)
-Add relationship to DBFMVehicleTable cardinality: zeroone, related table cardinality: exactlyone, relationship type: association

Activity 5b:
-set label of VendGroup field on VendTable to "Vendor group" by using label files
-open table browser of VendTable to check the additional field
-open all vendors to check the updated label



Form Extensions:
-extend the FMRental form by importing it again in our project and searching it in the AOT, and create an extension of it in our project
-because we created an extension earlier of the FMRental table (correction the VendTable table) the field which is vehicle id would have been added and the relation it had to our DBFMVehicleTableTest
-we add this field to a sub pattern "info group" under the main pattern "tab details" in our design pattern tab 
-we add another data source, which will be our DBFMVehicleTableTest and set this new data source, join source property to the FMRental datasource, its allow create, delete, insert at end and edit to no
-drag the field group identification of our data source DBFMVehicleTableTest to the "tab details" > "line view" > "line view tab" > "line view header"


Activity 6:
-extend All Vendors form
-add the vehicle id field on the grid and place beside the name field of the allvendors form
-add vehicle id and VIN on invoice and delivery > delivery. After destination code
-display most recent service start date (from DBFMVehicleMaintenance) of vehicle next to VIN
-VIN must not be editable


DAY 6
unknown methods and classes:

SrsReportRunController
SysOperationContractProcessingAttribute(classStr(DBFMVehicleMaintenanceUIBuilder))
rpt_ctrlr.parmReportName(ssrsReportStr(DBFMVehiclMaintenanceReport, DBFMVehicleMaintenanceReportDesign));
rpt_ctrlr.parmDialogCaption("<some caption>");
rpt_ctrlr.parmArgs(_args)
rpt_ctrlr.startOperation()
this.parmReportContract().parmRdpContract()
this.parmArgs().dataset()
this.parmArgs()
tableNum(DBFMVehicleMaintenanceTable)
this.parmArgs().record() as DBFMVehicleMaintenanceTable;
this.prePromtModiifyContract()

[SrsReportParameterAttribute(classStr(DBFMVehicleMaintenanceContract))]
SrsReportDataProviderPreProcessTempDB
this.parmDataContract() as DBFMVehicleMaintenanceContract;
this.processReport()
[SrsReportDatasetAttribute(tableStr(DBFMVehicleMaintenanceReportTable))]


[
    DataContractAttribute,
    SysOperationContractProcessingAttribute(classStr(DBFMVehicleMaintenanceUIBuilder))
]
[
        DataMemberAttribute('VehicleId'),
        SysOperationLabelAttribute('Vehicle Id')
    ]

[
        DataMemberAttribute('ReleaseDate'),
        SysOperationLabelAttribute('Release Date')
    ]

Dialog dialog = new Dialog("Create new customer");
DialogField df_cust_acc = Dialog.addField(extendedTypeStr(CustVendAC), "Account number");
df_cust_acc.value();

cust_table.validateWrite()
cust_table.insert()

[ExtensionOf(tableStr(CustTable))]
this.insert(DirPartyType _partyType, Name _name, boolean _updateCRM)
str2Int(this.creditRating)

[DataEventHandler(tableStr(CustTable), DataEventType::Inserting)]
this.CustTable_onInserting(Common sender, DataEventArgs e)

[FormEventHandler(formStr(FMRental), FormEventType::Initialized)]
public static void FMRental_OnInitialized(xFormRun sender, FormEventArgs e)
FormRun form_run = sender;
FormControl fmrental_state_copy_1 = form_run.design().controlName(formControlStr(FMRental, FMRental_StateCopy1));
fmrental_state_copy_1.valueStr()
fmrental_state_copy_1.enabled(false)

[FormControlEventHandler(formControlStr(FMRental, FMRental_StateCopy1), FormControlEventType::Modified)]
public static void FMRental_StateCopy1_OnModified(FormControl sender, FormControlEventArgs e)
sender.valueStr()
sender.enabled(false)

[FormDataSourceEventHandler(formDataSourceStr(FMRental, FMRental), FormDataSourceEventType::Activated)]
public static void FMRental_OnActivated(FormDataSource sender, FormDataSourceEventArgs e)
FormRun form_run = sender.formRun();
FormControl fmrental_state_copy_1 = form_run.design().controlName(formControlStr(FMRental, FMRental_StateCopy1));
FormControl fmrental_state_copy_1 = form_run.design().controlName(formControlStr(FMRental, FMRental_StateCopy1));
FormDataObject fm_rental_state = sender.object(fieldNum(FMRental, State));
fm_rental_state.enabled(fm_rental.State != FMReservationState::Complete);

[FormDataFieldEventHandler(formDataFieldStr(FMRental, FMRental, State), FormDataFieldEventType::Modified)]
public static void State_OnModified(FormDataObject sender, FormDataFieldEventArgs e)
anytype field_val = sender.getValue();
sender.enabled(sender.getValue() != FMReservationState::Complete);

[FormDataSourceEventHandler(formDataSourceStr(VendTable, VendTable), FormDataSourceEventType::Activated)]
public static void VendTable_OnActivated(FormDataSource sender, FormDataSourceEventArgs e)
VendTable vend_table = sender.cursor();
FormDataObject vend_table_fzone = sender.object(fieldNum(VendTable, FreightZone));
vend_table_fzone.enabled(!vend_table.FreightZone);

[ExtensionOf(tableStr(VendTable))]
public void initValue()
[SysClientCacheDataMethodAttribute(true)]




Reports (sql server reporting service)
-advantage of it is, it is built-in back-office document management capabilities
-another advantage is that precision documents to comply with local regulatory business practices
-parameterized views and drill-through navigations to other AX pages and other reports

Financial reporting
-22 default financial reports are available that can be overridden
-users can edit or create new reports
-requires the proper privileges and duties

Report contract class
-report class defines parameters to the ssrs report

Report UIBuilder class
-add any type of fields

Report controller class
-modifying a report query based on the ipnput data
-modifying report contract data based on the in data
-control a report parameters dialog
-to create extend SrsReportRunController class

Report data provider class (RDP)
-RDP is the data source type when we add a new dataset to the report in VS
-RDP is a class that executes the business logic process the data and returns a dataset which is rendered/shown in the report
-cannot directly use a query to access the data from the database
-data has to prepare on teh basis of business logic

-consider page layout page size margins if it is pre-printed or free form when creating a report forom scratch
-pre-printed reports - already ahve a printed form layout

-create temporary table
-create contract class
-create report data provider class
-create report and report design (report needs to be deployed)
-create controller class
-create output menu item
-run report



-add a query property value to the dataset nodes element we created which is DBFMVehicleReportDS
-add new precision design under the precision design node of the report
-in the newly added precision design node right click and click edit using designer which will open up another tab where we can design the report layout shown to the user
-you can add a header or foot to the report body
-in there port body add the ff: Vehicle ID, VIN, Vehicle Gross Weight to do this right click the report layout and click insert. The object we will be inserting can be usually a text box, line, table, rectangle, list, image, chart etc.
-right click the outside of the report layout and click report properties to change the margin, paper size, paper orientation etc.


activity 7:
-from vehicle maintenance list page, create a button that will display vehicle information and list all maintnance details related on the selected vehicle
-how does the report somehow now what report to display based on the selected row


2 ways on how to modify report layout of a built in report (FOR REFACTORING)
-report layout can be modified on controller class by overriding the standard controller class
-report that uses print management can be modified by extending PrintMgmtReportFormatPopulator class to add new report layout and also by extending PrintMgmtDocType class to identify which report layout will be used depends on document type

-open in designer the built in VendPurchOrderJournal form
-search for the PurchPurchaseOrderOriginal menu item button in the design pattern tab either by usign the main explorer or AOT search engine
-open the menu item button in the designer or if used main explorer in searching right click the button and click go to menu item output PurchPurchaseOrderOriginal

-since a output menu item uses a control class we use the information that will be provided in the menu items properties as basis for us to search the name of the class in the AOT
-search the class name and view its code

-search for PurchPurchaseOrderDP class and view its code

-search for the PurchPurchaseOrder report 
-in its datasets node are the elements PurchPurchaseOrderLine and PurchPurchaseOrderDS, click the latter and see its query property
-the query is PurchPurchaseOrderDP.PurchPurchaseOrderHeader which is the method that uses the shall we say [SrsReportDatasetAttribute(tableStr(DBFMVehicleReportTable))] decorator
-note: whenever a method of a data provider class uses this decorator it is what is part of the list of all choices for the query property of a dataset of a report
-so search PurchPurchaseOrderHeader and create an extension for it. (This is a table BTW)
-create another string extended data type named DBFMDescription and add it in our extended table

-search use the <name> of teh <class name>DP class and the <class name>
-duplicate it in our project
-rename it
-in the PurchPurchaseOrderDS dataset of the datasets node restore it so we can see the field we added earlier in the table since this dataset depends on this table for its query property
-once done make sure to deploy reports

go to modules > accounts payable > purchase orders > all purchase orders > select a record > in the action pane tab select purchase > purchase order confirmations > in the preview/print select box select original preview or print management





Activity 8 (Pending):
We are tasked a problem: in the click path "modules > sales and marketing >  sales orders > all sales orders > action tab pane" select pick and pack. 
We then look for a record that has its field status set to invoiced or delivered. 
Once record is selected click packing slip journal (which is a display menu item that directs to the CustPackingSlipJournal the form that we are looking for that contains the output menu item button that directs to the report) once in the page follow again the click path preview/print > original preview, which will generate a report. This is the report that we need to customize
So this problem asks of us two things in order to edit the report: what report we need to edit and what table specifically does the report use for its header, body, and footer components?

We do not know the name of the table itself let alone the report, however we can do this by identifying what menu we are in based on the click path we had to follow to get to teh page which contains all the sales orders records
Because ew are in the sales and marketing module we can use these as keywords to search in the AOT what its menu name is. Once we find it we can right click it and select open in designer
Once in we can then use the main tab search filter to search what menu item specifically what output menu item directs to the form that contains the table that we need
Because we know what display menu item in the UI leads to the list of all sales orders based on the click path that we followed to access these list of all sales orders we can use its keywords as basis to search for that specific display menu item
Once we find a the display menu item that resembles "all sales orders" we can identify the value of its properties object and object type. And in here we can extract out the form that it leads to when clicked based on its object property
We use the name of this form as input for the search filter in the AOT and once we find the form we open it again in the designer
Because we have another form to go to that contains the button that leads to the report itself we have to search in this current form we have what display menu item does in fact lead to this form in this case its the "pick and pack" display menu item that we need to search and then identify what form it uses
Once form is identified we search it again in the AOT




to know what method we will override we need to go to the report and identify which controller class and data provider class depends and is depended on


-add the new field named DBFMReference
-duplicate the standard report and layout
-modify the PrintMgmtReportFormatPopulator to add new report document layout. The doc type is PrintMgmtDocumentType::SalesOrderPackingSlip
-modify the PrintMgmtDocTypeHandlerExt to add new report document layout. The doc type is PrintMgmtDocumentType::SalesOrderPackingSlip
-extend the SalesInvoiceDP class to add the value on newly added field
-for the new field the field must be a string that concatenates the other fields of table the report is using which is packing slip number and the packing slip sales order e.g. strFmt("%1-%2", packing slip sales order, packing slip number)

search salespackingsliporiginal output menu item
identify what controller class it has: SalesPackingSlipController
search for the data provider class: SalesPackingSlipDP
search for the report: SalesPackingSlip
where to add the extra field? in the header of the report
what is the query of the dataset element that is used by the header of the report? SalesPackingSlipDP.SalesPackingSlipHeaderTmp

since we are trying to get the data of a header of a SalesPackingSlipHeaderTmp

file: SalesPackingSlipDBFMS_Extension.xpp
[ExtensionOf(classStr(SalesPackingSlipDP)]
final class SalesPackingSlipDPDBFMS_Extension
{
	// this si what populates the data of a temporary table of a report
	// like what we did in the this.populateData() method of our own data provider class
	// this returns a temporary table SalesPackingSlipHeaderTmp
	protected SalesPackingSlipHeaderTmp initializeSalesPackingSlipHeader()
	{
		SalesPackingSlipHeaderTmp salesPackingSlipHeaderTmpLocal = next initializeSalesPackingSlipHeader();
		
		salesPackingSlipHeaderTmpLocal.DBFMSReference = strFmt("%1-%2", 
			this.parmCustPackingSlipJour().SalesId, 
			this.parmCustPackingSlipJour().PackingSlipId);
		
		return salesPackingSlipHeaderTmpLocal;
	}
}


I think this is the main file which allows the user to choose between what print management report format to choose like what we did in the PurchPurchaseOrder report we had now two formats to choose from one was the 
file: PrintMgmtReportFormatPopulatorDBFMS_Extension
[ExtensionOf(classStr(PrintMgmtReportFormatPopulator))]
final class PrintMgmtReportFormatPopulatorDBFMS_Extension
{
	#PrintMgmtSetup

	protected void addDocuments()
	{
		this.addCustomReportDocuments();
		next addDocuments();
	}

	private void addCustomReportDocuments()
	{
		this.addOther(PrintMgmtDocumentType::SalesOrderPackingSlip, 
			ssrsReportStr(SalesPackingSlipDBFMS, ReportCustom), 
			ssrsReportStr(SalesPackingSlipDBFMS, ReportCustom), #NoCountryRegionId);
	}
}







Security basics
-sign in via AAD -> AAD redirects to AX7/dynamics 365 -> AX7/dynamics 365 start page display
-role based security comprises of duties, duties comprise of privileges (but security roles can also comprise of privileges), and privileges comprise of permissions which from your knowledge in django are the things that a user can do in a web application
-extensible data security framework comprise of a query, security policy, context and contrained tables
-users are assigned to one or more roles depending on their job that take into account the organization size, culture, and industry focus
-in designing roles it comprises of types and segregation categories

-create security duty
-add SysDataAreamaintain privilege

-buttons can have permissions like allow create, read, update, delete, partial update etc.
-table and form fields fields can also ahve permisisons like allow edit allow edit on create, mandatory, and minimum read access
-menu items also has permissions like read, correct, create, update, and delete permissions and has properties like permisison type, permission object child, linked permission object
-read -> correct -> update -> create -> delete is the heirarchy





DAY 7
Power BI
-consists of features like in-memory aggregate models, aggregate data entities, aggregate programming model, aggregate measurements and dimensions, and new KPI modelling
-types are contextual embedded, and self-service
-power BI can be a middle man between other I think MS appliciations. Could it be that this is like an API that allows dynamics 365 to integrate with other MS apps
-reporting services can be hoested in ms azure compute service, has a simplified development, administration and enhanced report viewing

Development process in power BI
-create reporting project in VS
-edit report in VS
-add report or I assume hook it to a menu item
-set menu item as start up object
-deploy report to server
-use ctrl + f5 to verify the report

Service and Integrations
-an X++ class can use yes SOAP, REST, and OData types of APIs. REST APIs in particular use HTTP/JSON data which I know.  OData is also a standard from Microsoft that relies on the REST Architecture to send specific types of messages over HTTP. The AtomPub protocol for instance is one of the best examples of REST API design. So, in a sense you are right - the OData is just another REST API and each OData implementation is a REST-ful web service. The difference is that OData is a specific protocol; REST is architecture style and design pattern.
-an X++ class can also access the Azure SQL database
-a data entity which depends on an X++ class, table, relational query, and an aggregate query can also access the Azure SQL database
-for the OData type of API it provides a simple and uniform way to share data in a discoverable fashion through uniform URL conventions. It also enables broad integration across other microsoft products and supports consumption in PowerBI.com as a refreshable data source

Workflows





Data entity
-is a de-normalized view of database tables
-provides a single stack to capture business logic
-provides primary mechanism to extract/insert datasets
-replaces diverging concepts of DIXF entities
-categories of data entities range from parameters, reference, master, document, and transaction
-is used mainly in synchronous services, asynchronous integration, data migration, and business intelligence


Activity 9:
-go to data management in the work spaces
-once in the page click data entities

-go to the VendGroup table in accounts payable > vendors
-in the page we will see a button open as (excel etc.)
-if it shows that the table acn be opened in excel then it is already a data entity

-in our DBFMVehicleTable add a primary index property which is set to our created index element DBFMVehicleIdx
-synchronize the database
-right lcick our created tabl > addins > data entity or create a new data entity called DBFMVehicleDataEntity
-in the wizard our primary data source will be our created DBFMVehicleTable
-set the DBFMVehicleID to mandatory in the wizard

-go again to the data management in work spaces
-click the framework parameter tiles
-click refresh entity list which will show this message: The entity list is being refreshed. Job execution during this time must be stopped. After this operation is completed, entities already published to your database must be re-published if required to ensure schema consistency. Entities on which change tracking was enabled must also be evaluated with the new metadata changes and if needed, change tracking must be disabled and re-enabled to ensure change tracking is consistent with the updated schema of the entity.
-if nothing is shown when clicking hte framework parameter tiles create a runnable class
-once refresh is done click the the data entity tile in the data management page
-search our created data entity which is DBFMVehicleTable

file: RefreshEntityList.xpp
class RefreshEntityList
{
	public static void main(Args _args)
	{
		DMFDataPopulation::createDefaultMappingAsync();
	}
}






Unfortunate errors that are occuring in the project:
BLANK


weaknesses:
difficulty wrapping my head around sql select statements, since the variable used to represent a table is used also to take in the would be value of the selected rows of a table
- why a variable is without instantiation to a table is because that variable anyway will hold a specific entity instance of the table by virtue of using the select statement
- unlike select statements in sql select statements in x++ only return one instance of an entity
-fields in tables and forms by default just set the tables properties to yoru master values and then if you are going to let the user edit something or create or delete then set these on the forms object instead. Instead of always having to change the master property values of a table
overrriding methods and accessing the tables or forms within overriden methods of tables and forms
architecture of the whole system
-overriding existing reports




​
Salutation
Good evening Maam/Sir


introduction
this is <insert name>

body
This is Larry Miguel Cueva po, just wanted to pass my updated version of last weeks activity report for the practicum

closing



